<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Teste de Crash WebGL</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: Arial; }
        canvas { display: block; }
        #warning { position: absolute; top: 10px; left: 10px; }
    </style>
</head>
<body>
    <div id="warning">AVISO: Este site pode crashar seu navegador! Clique o botão com cuidado.</div>
    <button onclick="startCrash()">Iniciar Teste de Crash</button>
    <canvas id="gl-canvas" width="800" height="600"></canvas>

    <script>
        function startCrash() {
            const canvas = document.getElementById('gl-canvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                alert('WebGL não suportado. O crash não funcionará.');
                return;
            }

            // Shader básico para renderizar
            const vertexShaderSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            const fragmentShaderSource = `
                precision mediump float;
                void main() {
                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                }
            `;

            // Função para criar shader
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Erro no shader:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            // Criar programa WebGL
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            // Configurar vértices para um quadrado grande
            const vertices = new Float32Array([
                -1.0,  1.0,
                 1.0,  1.0,
                -1.0, -1.0,
                 1.0, -1.0
            ]);
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Função para criar texturas enormes
            function createLargeTexture() {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                // Textura de 8192x8192 (máximo em muitas GPUs)
                const size = 8192;
                const data = new Uint8Array(size * size * 4); // RGBA
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                return texture;
            }

            // Loop para sobrecarregar memória e GPU
            let textures = [];
            function crashLoop() {
                try {
                    // Criar texturas até esgotar memória
                    for (let i = 0; i < 100; i++) {
                        textures.push(createLargeTexture());
                    }

                    // Renderizar repetidamente
                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    // Loop infinito de draw calls
                    for (let i = 0; i < 100000; i++) {
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    }

                    // Continuar o loop
                    requestAnimationFrame(crashLoop);
                } catch (e) {
                    console.error('Erro detectado:', e);
                }
            }

            // Iniciar o loop de crash
            crashLoop();
        }
    </script>
</body>
</html>
